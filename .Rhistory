y = c(y_T, y_S)
n = length(y)
# Find the updated parameters
# According to part (a)
beta1_update = ((sum(y_T*x_T) +
sum((y_S_pred_old + sigma_old*rho_S)*x_S))*n
- (sum(x))*(sum(y_T) + sum(y_S_pred_old + sigma_old*rho_S)))/
(n*sum(x^2) - (sum(x))^2)
beta0_update = (sum(y_T) + sum(y_S_pred_old + sigma_old*rho_S) - beta1_update*sum(x))/n
y_T_pred_new = beta0_update + beta1_update * x_T
y_S_pred_new = beta0_update + beta1_update * x_S
sigma2_update = (sum((y_S_pred_old - y_S_pred_new + sigma_old*rho_S)^2
+ sigma_old^2 * (1+tau_S*rho_S-rho_S)^2)
+ sum((y_T - y_T_pred_new)^2))/n
theta_update = c(beta0_update, beta1_update, sigma2_update)
# Return the vector of updated parameters
return(theta_update)
}
############################################################
# Process of doing EM
# Find the true observations and censored observations
# 80% quantile as tau
qt = 0.8
tau = quantile(yComplete, qt)
censor_ind = (yComplete >= tau)
x_sensor = x[censor_ind]
y_sensor = yComplete[censor_ind]
x_true = x[-censor_ind]
y_true = yComplete[-censor_ind]
# Initialize
theta = c(3,2,3)
err = 1
# The tolerance for err is 1e-8.
# err is measured as the L2 norm for difference
# between old and updated thetas
count = 0
while(err > 1e-8){
theta_update = update(x_true, y_true, x_sensor, y_sensor, tau, theta)
err = norm(theta - theta_update, type = '2')
theta = theta_update
count = count + 1
}
# Print the result
print(theta)
# Print the time of iteration
print(count)
############################################################
# Make 20% quantile as tau
############################################################
# Process of doing EM
# Find the true observations and censored observations
qt = 0.2
tau = quantile(yComplete, qt)
censor_ind = (yComplete >= tau)
x_sensor = x[censor_ind]
y_sensor = yComplete[censor_ind]
x_true = x[-censor_ind]
y_true = yComplete[-censor_ind]
# Initialize
theta = c(3,2,3)
err = 1
# The tolerance for err is 1e-8.
# err is measured as the L2 norm for difference
# between old and updated thetas
count = 0
while(err > 1e-8){
theta_update = update(x_true, y_true, x_sensor, y_sensor, tau, theta)
err = norm(theta - theta_update, type = '2')
theta = theta_update
count = count + 1
}
# Print the result
print(theta)
# Print the time of iteration
print(count)
# This function returns the negative log-likelihood
# given parameters theta
NLL = function(theta, x_true, y_true, x_sensor, y_sensor, tau){
beta_0 = theta[1]
beta_1 = theta[2]
sigma2 = theta[3]
LL = 0
for(i in 1:length(y_true)){
LL = LL + log(dnorm(y_true[i], mean = beta_0 + beta_1 * x_true[i], sd = sqrt(sigma2)))
}
for(i in 1:length(y_sensor)){
LL = LL + log(1 - pnorm(tau, mean = beta_0 + beta_1 * x_sensor[i], sd = sqrt(sigma2)))
}
LL = -LL
return(LL)
}
# initialization and optimization
qt = 0.8
tau = quantile(yComplete, qt)
censor_ind = (yComplete >= tau)
x_sensor = x[censor_ind]
y_sensor = yComplete[censor_ind]
x_true = x[-censor_ind]
y_true = yComplete[-censor_ind]
theta = c(3,2,3)
# Optimization
theta_opt = optim(par = theta, fn = NLL, method = 'BFGS',
x_true = x_true, y_true = y_true,
x_sensor = x_sensor, y_sensor = y_sensor,
tau = tau, hessian = TRUE)
# Print the estimators
print(theta_opt$par)
# Print the count of iterations
print(theta_opt$counts)
# The estimation standard errors of estimators
print(solve(theta_opt$hessian))
x = list(c(1,2))
sample(x, 1)
rbinom(n = 100, size = 1, prob = 0.5)
rbinom(n = 5, size = 1, prob = 0.5)
x = 1:5
x[rbinom(n = 5, size = 1, prob = 0.5)]
ind = rbinom(n = 5, size = 1, prob = 0.03)
ind
x[ind]
x[ind] = 5
x
x = 1:5
x[ind]
in
ind
y = 1
z = 2
x = sample(list(y,z),1)
x
x = sample(list(y,z),1)
x
rbinom(5, 1, 0.01)
fit = vector()
fit
AIC()
?AIC
x = 1:100
y = 1:100
obj = lm(y~x)
AIC(obj)
ncol(x)
?ncoul
?ncol
setwd('~/Desktop/GA')
getwd()
getwd()
library(rlist)
load('fitness/project.R')
load('crossover/crossover.R')
library(rlist)
source('fitness/project.R')
source('crossover/crossover.R')
getwd()
setwd('/Users/feichengqi/Desktop/201b_FINAL/')
setwd('..')
setwd('~/GA')
getwd()
setwd('GA')
View(list_gene)
library(rlist)
source('fitness/project.R')
source('crossover/crossover.R')
View(fitness2)
fitness2(list_gene, data = data)
rank(c(3,2,1))
?rank
rank(x = c(3,2,1), order = 01)
rank(x = c(3,2,1), order = -1)
frank(c(1,2,3), order = -1)
install.packages('data.frame')
?rank
library('data.table')
frank(c(3,2,1), order = 01)
frank(c(3,2,1), order = -1)
?frank
frankv(c(4,2,1), order = 01)
frankv(c(4,2,1), order = -1)
runif(n = 100)
fitness_score = c(1,2,3,4,5,6)
p = length(fitness_score)
fitness_rank = frankv(fitness_score, order = -1)
fitness_rank
selection_prob = 2*fitness_rank / (p^2 + p)
selection_prob
sum(selection_prob)
parents = sample(1:p, size = p, replace = TRUE, prob = selection_prob)
parents
4//
4//2
parents = matrix(rlogical(n^2), n, n)
View(parents)
child_a = ga_crossover(parents[,1], parents[,2])
View(parents)
child_a = ga_crossover(parents[,1], parents[,2])
y = [1,2,3,4,5]
y = list(c(1,2,3,4,5))
y
y = list(1,2,3,4,5)
y
apply(y, MARGIN = 0, print)
apply(y, MARGIN = 1, print)
apply(y, MARGIN = 0, print)
View(y)
lapply(y, print)
# This function computes the GA results
# dim is the dimension of genes
# p is the number of individuals in population
# t is the time of iterating
GA_compute = function(dim, p, t = 100){
pop = GA_initialize(dim, p)
for(i in 1:t){
# Find fitness
fitness_score = fitness2(pop, data, fitness = AIC, func = lm)
#UPDATE(pop)
children = list()
parents = pop[select_index(fitness_score)]
p = length(parents)
for(i in 1:p/2){
children = list.append(children, unlist(ga_crossover(parentA = parents[i], parentB = parents[p-i+1])))
}
children = lapply(children, ga_mutate)
}
pop = children
return(pop)
}
y = c(1,3,5,7,9)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
pop = GA_compute(dim = 3, p = 20, t = 100)
GA_initialize = function(dim, p = 20){
individuals = list()
for(i in 1:p){
individual = runif(n = dim) > 0.5
individuals = list.append(individuals, individual)
}
return(individuals)
}
pop = GA_compute(dim = 3, p = 20, t = 100)
select_index = function(fitness_score){
p = length(fitness_score)
# Ascending rank
fitness_rank = frankv(fitness_score, order = -1)
selection_prob = 2*fitness_rank / (p^2 + p)
parents = sample(1:p, size = p, replace = TRUE, prob = selection_prob)
return(parents)
}
pop = GA_compute(dim = 3, p = 20, t = 100)
# For the subset of child that needs to be mutated, flip values
child[changes] = !child[changes]
library(rlist)
library(data.table)
source('fitness/project.R')
source('crossover/crossover.R')
pop = GA_compute(dim = 3, p = 20, t = 100)
pop
pop = GA_initialize(3, 20)
pop
for(i in 1:p/2){
children = list.append(children, unlist(ga_crossover(parentA = parents[i], parentB = parents[p-i+1])))
}
children = list()
for(i in 1:p/2){
children = list.append(children, unlist(ga_crossover(parentA = parents[i], parentB = parents[p-i+1])))
}
children
parents = pop
children = list()
for(i in 1:p/2){
children = list.append(children, unlist(ga_crossover(parentA = parents[i], parentB = parents[p-i+1])))
}
children = list()
p = length(parents)
for(i in 1:p/2){
children = list.append(children, unlist(ga_crossover(parentA = parents[i], parentB = parents[p-i+1])))
}
children
ga_crossover(c(1,2,3,4), c(1,2,3,4))
View(data)
View(pop)
pop[1]
pop[1][1]
GA_compute = function(dim, p, t = 100){
pop = GA_initialize(dim, p)
for(i in 1:t){
# Find fitness
fitness_score = fitness2(pop, data, fitness = AIC, func = lm)
#UPDATE(pop)
children = list()
parents = pop[select_index(fitness_score)]
p = length(parents)
for(i in 1:p/2){
children = list.append(children, unlist(ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])))
}
children = lapply(children, ga_mutate)
}
pop = children
return(pop)
}
select_index = function(fitness_score){
p = length(fitness_score)
# Ascending rank
fitness_rank = frankv(fitness_score, order = -1)
selection_prob = 2*fitness_rank / (p^2 + p)
parents = sample(1:p, size = p, replace = TRUE, prob = selection_prob)
return(parents)
}
GA_initialize = function(dim, p = 20){
individuals = list()
for(i in 1:p){
individual = runif(n = dim) > 0.5
individuals = list.append(individuals, individual)
}
return(individuals)
}
y = c(1,3,5,7,9)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
pop = GA_compute(dim = 3, p = 20, t = 100)
pop
pop = GA_initialize(dim = 3)
pop
fitness_score = fitness2(pop, data, fitness = AIC, func = lm)
fitness_score
parents = pop[select_index(fitness_score)]
parents
children = list()
p = length(parents)
for(i in 1:p/2){
children = list.append(children, unlist(ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])))
}
children
ga_crossover = function(parentA, parentB){
# This function take in two parents and uses a simple split
# to create children. It then picks a random child to pass on
# in the algorithm
n = length(parentA)
splitpt = sample(1:(n-1),1)
# Create two children
childA = parentA
childA[(splitpt+1):n] = parentB[(splitpt+1):n]
childB = parentB
childB[(splitpt+1):n] = parentA[(splitpt+1):n]
# Randomly pick one child to return
# Return both childs
return(list(childA, childB))
}
for(i in 1:p/2){
children = list.append(children, unlist(ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])))
}
children
for(i in 1:p/2){
children = list.append(children, ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]]))
}
children
children = list()
for(i in 1:p/2){
children = list.append(children, ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])[c(1,2)])
}
children
children = list()
children
for(i in 1:p/2){
children = list.append(children, ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])[[c(1,2)]])
}
children
for(i in 1:p/2){
children = list.append(children, ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]]))
}
children
children = list()
for(i in 1:p/2){
children = vstack(children, ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]]))
}
children = list()
for(i in 1:p/2){
children = hstack(children, ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]]))
}
z = list(c(1,2,34), c(2,3,4))
unlist(z)
children = list()
for(i in 1:p/2){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children = list.append(children, childs[[1]], childs[[2]])
}
children
pop = GA_initialize(dim = 3, p = 20)
fitness_score = fitness2(pop, data, fitness = AIC, func = lm)
fitness_score
parents = pop[select_index(fitness_score)]
parents
p = length(parents)
p
for(i in 1:p/2){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children = list.append(children, childs[[1]], childs[[2]])
}
children
children = list()
for(i in 1:p/2){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children = list.append(children, childs[[1]], childs[[2]])
}
children
?list.append
children = list()
for(i in 1:p/2){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children = list.append(children, childs[[1]], childs[[2]])
print(length(children))
}
children = list()
for(i in 1:(p/2)){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children = list.append(children, childs[[1]], childs[[2]])
print(length(children))
}
children
GA_compute = function(dim, p, t = 100){
pop = GA_initialize(dim, p)
for(i in 1:t){
# Find fitness
fitness_score = fitness2(pop, data, fitness = AIC, func = lm)
#UPDATE(pop)
children = list()
parents = pop[select_index(fitness_score)]
p = length(parents)
for(i in 1:(p/2)){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children = list.append(children, childs[[1]], childs[[2]])
}
children = lapply(children, ga_mutate)
}
pop = children
return(pop)
}
pop = GA_compute(dim = 3, p = 20, t = 100)
pop
rank = frankv(fitness2(pop, data, fitness = AIC, func = lm), order = -1)
rank
?frankv
rank = frankv(fitness2(pop, data, fitness = AIC, func = lm), order = -1, ties.method = 'first')
rank
pop[rank]
pop
rank
pop[rank]
fitness_rank = frankv(c(1,2,3), order = -1)
fitness_rank
rank = frankv(fitness2(pop, data, fitness = AIC, func = lm), order = 1, ties.method = 'first')
rank
x = c(2,4,21,23,3,1,2,)
x = c(2,4,21,23,3,1,2)
x[frankv(x, order = 1, ties.method = 'first')]
x
x[frankv(x, order = 1, ties.method = 'first')]
x
pop[rank == 1]
fitness <- function(mod ,func = AIC){
fitvec <- vector()
for (i in 1:length(mod)) {
fitvec <- c(fitvec, func(mod[[i]]))
}
vec <- order(fitvec)
rank_mod <- list()
for (i in order(fitvec)) {
rank_mod <-c(rank_mod,mod[i])
}
return (-rank_mod)
}
fitness <- function(mod ,func = AIC){
fitvec <- vector()
for (i in 1:length(mod)) {
fitvec <- c(fitvec, func(mod[[i]]))
}
vec <- order(fitvec)
rank_mod <- list()
for (i in order(fitvec)) {
rank_mod <-c(rank_mod,mod[i])
}
return (-rank_mod)
}
fitness <- function(mod ,func = AIC){
fitvec <- vector()
for (i in 1:length(mod)) {
fitvec <- c(fitvec, func(mod[[i]]))
}
vec <- order(fitvec)
rank_mod <- list()
for (i in order(fitvec)) {
rank_mod <-c(rank_mod,mod[i])
}
return (rank_mod)
}
fitness2 <- function(list_of_gene, data, fitness = AIC, func = lm) {
fitness_value <- vector()
for (i in 1:length(list_of_gene)){
gene <- list_of_gene[[i]]
gene_map <- rep(TRUE,length(gene))
for (j in 1:length(gene)){
if (gene[j] == 0){gene_map[j] <- FALSE}
}
regression_data <- data[,gene_map]
regression_data <- data.frame(y,regression_data)
model <- func(y~., data = regression_data)
fitness_value <- c(fitness_value,fitness(model))
}
return (-fitness_value)
}
y = c(1,3,5,7,9)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
pop = GA_compute(dim = 3, p = 20, t = 100)
rank = frankv(fitness2(pop, data, fitness = AIC, func = lm), order = -1, ties.method = 'first')
pop[rank == 1]
