pop = children
}
return(pop)
}
select_index = function(fitness_score){
p = length(fitness_score)
# Ascending rank with respect to fitness score
fitness_rank = frankv(fitness_score, order = 1)
selection_prob = 2*fitness_rank / (p^2 + p)
parents = sample(1:p, size = p, replace = TRUE, prob = selection_prob)
return(parents)
}
y = c(1,3,5,7,9)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
pop = GA_compute(dim = 3, p = 20, t = 100)
rank = frankv(fitness2(pop, data, fitness = AIC, func = lm), order = -1, ties.method = 'first')
pop[rank == 1]
library(rlist)
library(data.table)
source('fitness/project.R')
source('crossover/crossover.R')
GA_initialize = function(dim, p = 20){
# This function takes dimension and the number of individuals
# and returns a list of initialized individuals
individuals = data.frame(matrix(runif(n = dim*p) > 0.5, dim, p))
return(as.list(individuals))
}
GA_compute = function(dim, p, t = 100){
# This function computes the GA results
# dim is the dimension of genes
# p is the number of individuals in population
# t is the time of iterating
pop = GA_initialize(dim, p)
for(i in 1:t){
# Find fitness
fitness_score = fitness2(pop,  data = data, fitness = AIC, func = lm)
#UPDATE(pop)
parents = pop[select_index(fitness_score)]
p = length(parents)
n_cross = floor(p/2)
children = list(n_cross*2)
for(i in 1:n_cross){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children[[(i*2-1)]] = childs[[1]]
children[[(i*2)]] = childs[[2]]
}
children = lapply(children, ga_mutate)
pop = children
}
return(pop)
}
select_index = function(fitness_score){
p = length(fitness_score)
# Ascending rank with respect to fitness score
fitness_rank = frankv(fitness_score, order = 1)
selection_prob = 2*fitness_rank / (p^2 + p)
parents = sample(1:p, size = p, replace = TRUE, prob = selection_prob)
return(parents)
}
y = c(1,3,5,7,9)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
pop = GA_compute(dim = 3, p = 20, t = 100)
rank = frankv(fitness2(pop, data, fitness = AIC, func = lm), order = -1, ties.method = 'first')
pop[rank == 1]
library(rlist)
library(data.table)
source('fitness/project.R')
setwd('..')
source('fitness/project.R')
source('crossover/crossover.R')
GA_initialize = function(dim, p = 20){
# This function takes dimension and the number of individuals
# and returns a list of initialized individuals
individuals = data.frame(matrix(runif(n = dim*p) > 0.5, dim, p))
return(as.list(individuals))
}
View(GA_initialize)
View(child_a)
GA_compute = function(dim, p, t = 100){
# This function computes the GA results
# dim is the dimension of genes
# p is the number of individuals in population
# t is the time of iterating
pop = GA_initialize(dim, p)
for(i in 1:t){
# Find fitness
fitness_score = fitness2(pop,  data = data, fitness = AIC, func = lm)
#UPDATE(pop)
parents = pop[select_index(fitness_score)]
p = length(parents)
n_cross = floor(p/2)
children = list(n_cross*2)
for(i in 1:n_cross){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children[[(i*2-1)]] = childs[[1]]
children[[(i*2)]] = childs[[2]]
}
children = lapply(children, ga_mutate)
pop = children
}
return(pop)
}
select_index = function(fitness_score){
p = length(fitness_score)
# Ascending rank with respect to fitness score
fitness_rank = frankv(fitness_score, order = 1)
selection_prob = 2*fitness_rank / (p^2 + p)
parents = sample(1:p, size = p, replace = TRUE, prob = selection_prob)
return(parents)
}
y = c(1,3,5,7,9)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
pop = GA_compute(dim = 3, p = 20, t = 100)
View(pop)
rank = frankv(fitness2(pop, data, fitness = AIC, func = lm), order = -1, ties.method = 'first')
rank
pop[rank == 1]
pop = GA_compute(dim = 10, p = 200, t = 100)
GA_initialize = function(dim, p = 20){
# This function takes dimension and the number of individuals
# and returns a list of initialized individuals
individuals = data.frame(matrix(runif(n = dim*p) > 0.5, dim, p))
return(as.list(individuals))
}
GA_compute = function(dim, p, t = 100){
# This function computes the GA results
# dim is the dimension of genes
# p is the number of individuals in population
# t is the time of iterating
pop = GA_initialize(dim, p)
for(i in 1:t){
# Find fitness
fitness_score = fitness2(pop,  data = data, fitness = AIC, func = lm)
#UPDATE(pop)
parents = pop[select_index(fitness_score)]
p = length(parents)
n_cross = floor(p/2)
children = list(n_cross*2)
for(i in 1:n_cross){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children[[(i*2-1)]] = childs[[1]]
children[[(i*2)]] = childs[[2]]
}
children = lapply(children, ga_mutate)
pop = children
}
return(pop)
}
select_index = function(fitness_score){
p = length(fitness_score)
# Ascending rank with respect to fitness score
fitness_rank = frankv(fitness_score, order = 1)
selection_prob = 2*fitness_rank / (p^2 + p)
parents = sample(1:p, size = p, replace = TRUE, prob = selection_prob)
return(parents)
}
y = c(1,3,5,7,9)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
pop = GA_compute(dim = 3, p = 20, t = 100)
rank = frankv(fitness_score(pop, data, fitness = AIC, func = lm), order = -1, ties.method = 'first')
pop[rank == 1]
library(rlist)
library(data.table)
source('fitness/project.R')
source('crossover/crossover.R')
GA_initialize = function(dim, p = 20){
# This function takes dimension and the number of individuals
# and returns a list of initialized individuals
individuals = data.frame(matrix(runif(n = dim*p) > 0.5, dim, p))
return(as.list(individuals))
}
GA_compute = function(dim, p, t = 100){
# This function computes the GA results
# dim is the dimension of genes
# p is the number of individuals in population
# t is the time of iterating
pop = GA_initialize(dim, p)
for(i in 1:t){
# Find fitness
fitness_score = fitness2(pop,  data = data, fitness = AIC, func = lm)
#UPDATE(pop)
parents = pop[select_index(fitness_score)]
p = length(parents)
n_cross = floor(p/2)
children = list(n_cross*2)
for(i in 1:n_cross){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children[[(i*2-1)]] = childs[[1]]
children[[(i*2)]] = childs[[2]]
}
children = lapply(children, ga_mutate)
pop = children
}
return(pop)
}
select_index = function(fitness_score){
p = length(fitness_score)
# Ascending rank with respect to fitness score
fitness_rank = frankv(fitness_score, order = 1)
selection_prob = 2*fitness_rank / (p^2 + p)
parents = sample(1:p, size = p, replace = TRUE, prob = selection_prob)
return(parents)
}
y = c(1,3,5,7,9)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
pop = GA_compute(dim = 3, p = 20, t = 100)
rank = frankv(fitness_score(pop, data, fitness = AIC, func = lm), order = -1, ties.method = 'first')
pop[rank == 1]
rank = frankv(fitness_score(pop, data, fitness = AIC, func = lm), order = -1, ties.method = 'first')
pop[rank == 1]
pop = GA_compute(dim = 3, p = 20, t = 100)
rank = frankv(fitness_score(pop, data, fitness = AIC, func = lm), order = -1, ties.method = 'first')
pop[rank == 1]
pop = GA_compute(dim = 4, p = 20, t = 100)
pop = GA_compute(dim = 3, p = 20, t = 100)
rank = frankv(fitness_score(pop, data, fitness = AIC, func = lm), order = -1, ties.method = 'first')
pop[rank == 1]
library(assertthat)
# The new fitness function.
#list_of_gene is a list of gene likes
#list(c(TRUE,FALSE,FALSE), c(TRUE,FALSE,TRUE), c(TRUE,FALSE,TRUE)).
#data is a dataframe containing several x columus.
#fitness is the fitness function, default in AIC.
#func is the regression method, likes lm or glm, default in lm.
#response is the response value (y).
#min: TRUE is for those fitness function the smaller the fitness value the better the model
#like AIC,while FALSE is for those the larger fitness value the better the model.
fitness_score <- function(list_of_gene, data, fitness = AIC, func = lm, response, min = TRUE) {
assert_that(!is.data.frame(data), msg = "the data must be a dataframe")
fitness_value <- vector()
for (i in 1:length(list_of_gene)){
gene <- list_of_gene[[i]]
regression_data <- data[,gene]
regression_data <- data.frame(y,regression_data)
model <- func(y~., data = regression_data)
fitness_value <- c(fitness_value,fitness(model))
}
if (min == TRUE){return (-fitness_value)} else{return (fitness_value)}
}
# test
fitness_score(list_gene, data = data, response = y)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
# The new fitness function.
#list_of_gene is a list of gene likes
#list(c(TRUE,FALSE,FALSE), c(TRUE,FALSE,TRUE), c(TRUE,FALSE,TRUE)).
#data is a dataframe containing several x columus.
#fitness is the fitness function, default in AIC.
#func is the regression method, likes lm or glm, default in lm.
#response is the response value (y).
#min: TRUE is for those fitness function the smaller the fitness value the better the model
#like AIC,while FALSE is for those the larger fitness value the better the model.
fitness_score <- function(list_of_gene, data, fitness = AIC, func = lm, response, min = TRUE) {
assert_that(is.data.frame(data), msg = "the data must be a dataframe")
fitness_value <- vector()
for (i in 1:length(list_of_gene)){
gene <- list_of_gene[[i]]
regression_data <- data[,gene]
regression_data <- data.frame(y,regression_data)
model <- func(y~., data = regression_data)
fitness_value <- c(fitness_value,fitness(model))
}
if (min == TRUE){return (-fitness_value)} else{return (fitness_value)}
}
# test
fitness_score(list_gene, data = data, response = y)
fitness_score(list_gene, data = data, func = glm, response = y)
cool <- c(7,6,5,4,7)
fitness_score(list_gene, data = cool, response = y)
data
length(data)
data.shape[0]
data.shape
nrow(data)
# The new fitness function.
#list_of_gene is a list of gene likes
#list(c(TRUE,FALSE,FALSE), c(TRUE,FALSE,TRUE), c(TRUE,FALSE,TRUE)).
#data is a dataframe containing several x columus.
#fitness is the fitness function, default in AIC.
#func is the regression method, likes lm or glm, default in lm.
#response is the response value (y).
#min: TRUE is for those fitness function the smaller the fitness value the better the model
#like AIC,while FALSE is for those the larger fitness value the better the model.
fitness_score <- function(list_of_gene, data, fitness = AIC, func = lm, response, min = TRUE) {
assert_that(is.data.frame(data), msg = "the data must be a dataframe.")
assert_that(length(response) == nrow(data),
msg = "the dimension of observed vector should be the same as that of response.")
fitness_value <- vector()
for (i in 1:length(list_of_gene)){
gene <- list_of_gene[[i]]
regression_data <- data[,gene]
regression_data <- data.frame(y,regression_data)
model <- func(y~., data = regression_data)
fitness_value <- c(fitness_value,fitness(model))
}
if (min == TRUE){return (-fitness_value)} else{return (fitness_value)}
}
# test
fitness_score(list_gene, data = data, response = y)
fitness_score(list_gene, data = data, func = glm, response = y)
fitness_score(list_gene, data = cool, response = y)
data2 <- data.frame(x1 = c(10,9,5,7), x2 = c(7,6,5,4), x3 = c(1,2,3,4))
fitness_score(list_gene, data = data2, response = y)
# The new fitness function.
#list_of_gene is a list of gene likes
#list(c(TRUE,FALSE,FALSE), c(TRUE,FALSE,TRUE), c(TRUE,FALSE,TRUE)).
#data is a dataframe containing several x columus.
#fitness is the fitness function, default in AIC.
#func is the regression method, likes lm or glm, default in lm.
#response is the response value (y).
#min: TRUE is for those fitness function the smaller the fitness value the better the model
#like AIC,while FALSE is for those the larger fitness value the better the model.
fitness_score <- function(list_of_gene, data, fitness = AIC, func = lm, response, min = TRUE) {
assert_that(is.data.frame(data), msg = "the data must be a dataframe.")
assert_that(length(response) == nrow(data),
msg = "the dimension of observed vectors should be the same as that of response vector.")
fitness_value <- vector()
for (i in 1:length(list_of_gene)){
gene <- list_of_gene[[i]]
regression_data <- data[,gene]
regression_data <- data.frame(y,regression_data)
model <- func(y~., data = regression_data)
fitness_value <- c(fitness_value,fitness(model))
}
if (min == TRUE){return (-fitness_value)} else{return (fitness_value)}
}
# test
fitness_score(list_gene, data = data, response = y)
fitness_score(list_gene, data = data, func = glm, response = y)
fitness_score(list_gene, data = cool, response = y)
fitness_score(list_gene, data = data2, response = y)
# test
fitness_score(list_gene, data = data)
library(rlist)
library(data.table)
source('fitness/project.R')
source('crossover/crossover.R')
GA_initialize = function(dim, p = 20){
# This function takes dimension and the number of individuals
# and returns a list of initialized individuals
individuals = data.frame(matrix(runif(n = dim*p) > 0.5, dim, p))
return(as.list(individuals))
}
GA_compute = function(dim, p, t = 100){
# This function computes the GA results
# dim is the dimension of genes
# p is the number of individuals in population
# t is the time of iterating
pop = GA_initialize(dim, p)
for(i in 1:t){
# Find fitness
fitness_score = fitness_score(pop,  data = data, fitness = AIC, func = lm)
#UPDATE(pop)
parents = pop[select_index(fitness_score)]
p = length(parents)
n_cross = floor(p/2)
children = list(n_cross*2)
for(i in 1:n_cross){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children[[(i*2-1)]] = childs[[1]]
children[[(i*2)]] = childs[[2]]
}
children = lapply(children, ga_mutate)
pop = children
}
return(pop)
}
select_index = function(fitness_score){
p = length(fitness_score)
# Ascending rank with respect to fitness score
fitness_rank = frankv(fitness_score, order = 1)
selection_prob = 2*fitness_rank / (p^2 + p)
parents = sample(1:p, size = p, replace = TRUE, prob = selection_prob)
return(parents)
}
y = c(1,3,5,7,9)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
pop = GA_compute(dim = 3, p = 20, t = 100)
rank = frankv(fitness_score(pop, data, fitness = AIC, func = lm, response = y), order = -1, ties.method = 'first')
pop[rank == 1]
View(pop)
library(rlist)
library(data.table)
source('fitness/project.R')
source('crossover/crossover.R')
GA_initialize = function(dim, p = 20){
# This function takes dimension and the number of individuals
# and returns a list of initialized individuals
individuals = data.frame(matrix(runif(n = dim*p) > 0.5, dim, p))
return(as.list(individuals))
}
GA_compute = function(dim, p, t = 100){
# This function computes the GA results
# dim is the dimension of genes
# p is the number of individuals in population
# t is the time of iterating
pop = GA_initialize(dim, p)
for(i in 1:t){
# Find fitness
fitness_score = fitness_score(pop,  data = data, fitness = AIC, func = lm)
#UPDATE(pop)
parents = pop[select_index(fitness_score)]
p = length(parents)
n_cross = floor(p/2)
children = list(n_cross*2)
for(i in 1:n_cross){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children[[(i*2-1)]] = childs[[1]]
children[[(i*2)]] = childs[[2]]
}
children = lapply(children, ga_mutate)
pop = children
}
return(pop)
}
select_index = function(fitness_score){
p = length(fitness_score)
# Ascending rank with respect to fitness score
fitness_rank = frankv(fitness_score, order = 1)
selection_prob = 2*fitness_rank / (p^2 + p)
parents = sample(1:p, size = p, replace = TRUE, prob = selection_prob)
return(parents)
}
y = c(1,3,5,7,9)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
pop = GA_compute(dim = 3, p = 20, t = 100)
rank = frankv(fitness_score(pop, data, fitness = AIC, func = lm, response = y), order = -1, ties.method = 'first')
pop[rank == 1]
library(rlist)
library(data.table)
source('fitness/project.R')
source('crossover/crossover.R')
GA_initialize = function(dim, p = 20){
# This function takes dimension and the number of individuals
# and returns a list of initialized individuals
individuals = data.frame(matrix(runif(n = dim*p) > 0.5, dim, p))
return(as.list(individuals))
}
GA_compute = function(dim, p, t = 100){
# This function computes the GA results
# dim is the dimension of genes
# p is the number of individuals in population
# t is the time of iterating
pop = GA_initialize(dim, p)
for(i in 1:t){
# Find fitness
fitness_score = fitness_score(pop,  data = data, fitness = AIC, func = lm)
#UPDATE(pop)
parents = pop[select_index(fitness_score)]
p = length(parents)
n_cross = floor(p/2)
children = list(n_cross*2)
for(i in 1:n_cross){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children[[(i*2-1)]] = childs[[1]]
children[[(i*2)]] = childs[[2]]
}
children = lapply(children, ga_mutate)
pop = children
}
return(pop)
}
select_index = function(fitness_score){
p = length(fitness_score)
# Ascending rank with respect to fitness score
fitness_rank = frankv(fitness_score, order = 1)
selection_prob = 2*fitness_rank / (p^2 + p)
parents = sample(1:p, size = p, replace = TRUE, prob = selection_prob)
return(parents)
}
y = c(1,3,5,7,9)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
pop = GA_compute(dim = 3, p = 20, t = 100)
rank = frankv(fitness_score(pop, data, fitness = AIC, func = lm, response = y), order = -1, ties.method = 'first')
pop[rank == 1]
GA_compute = function(dim, p, t = 100){
# This function computes the GA results
# dim is the dimension of genes
# p is the number of individuals in population
# t is the time of iterating
pop = GA_initialize(dim, p)
for(i in 1:t){
# Find fitness
fitness_score = fitness_score(pop,  data = data, fitness = AIC, func = lm, response = y)
#UPDATE(pop)
parents = pop[select_index(fitness_score)]
p = length(parents)
n_cross = floor(p/2)
children = list(n_cross*2)
for(i in 1:n_cross){
childs = ga_crossover(parentA = parents[[i]], parentB = parents[[p-i+1]])
children[[(i*2-1)]] = childs[[1]]
children[[(i*2)]] = childs[[2]]
}
children = lapply(children, ga_mutate)
pop = children
}
return(pop)
}
select_index = function(fitness_score){
p = length(fitness_score)
# Ascending rank with respect to fitness score
fitness_rank = frankv(fitness_score, order = 1)
selection_prob = 2*fitness_rank / (p^2 + p)
parents = sample(1:p, size = p, replace = TRUE, prob = selection_prob)
return(parents)
}
y = c(1,3,5,7,9)
data <- data.frame(x1 = c(10,9,5,7,6), x2 = c(7,6,5,4,3), x3 = c(1,2,3,4,5))
pop = GA_compute(dim = 3, p = 20, t = 100)
rank = frankv(fitness_score(pop, data, fitness = AIC, func = lm, response = y), order = -1, ties.method = 'first')
pop[rank == 1]
View(pop)
